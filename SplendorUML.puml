@startuml

class Jeu {
--
- nouvellePartie():void
- reprendrePartie():void
- verifAnciennePartie():void
- verifGagnant(): void
- sauvegarderPartie():void
- vainqueur(): Joueur
- auSuivant(): Joueur
- verifObligationRemplissage()
+ validationAction()
}

class Affichage{
- affichage()
- afficherRegles()
- afficherConditionVictoire()
- afficherPoint()
}


class Plateau {
- jetons:Jeton[25]
- privilege:Privilege[3]
- sac:Jeton[3]
- cartes_nobles:CarteNoble[3]
- nb_jetons_sac : unsigned int
- nb_jetons_plateau : unsigned int
- pointeur_case_libre : unsigned int
- nb_privileges : unsigned int
- nb_carte_noble : unsigned int
- selection_courante : const Jeton[]
- selection_courante_positions : int[]
- nombre_jetons_dans_selection : unsigned int
- nombre_jetons_par_cote_de_plateau unsigned
- nombre_jetons_dans_selection_MAX unsigned
- nb_jetons_sac_MAX  unsigned
- nb_privileges_MAX  unsigned
- nb_jetons_plateau_MAX unsigned int
-- methods --
- verificationSelectionPositions() : bool
+ etatPlateau() : string
+ remplissagePlateau(bool avecAffichage = false):
+ verificationChoixJetonPlateau()
+ ajouterSac(const Jeton *j)
+ selectionJeton(unsigned int position_x, unsigned int position_y)
+ validerSelectionEtPrendreJetons() : ReponseValidationSelection
+ prendreJeton(unsigned int position_x, unsigned int position_y) : const Jeton
+ prendrePrivilege() : const Privilege*
+ donnePrivilege(const Privilege* p)
+ prendreCarteNoble(unsigned int numero) : const CarteNoble*
+ hasJeton() : bool
}
struct ReponseValidationSelection {
    + jetons:const Jeton*[]
    + nombre: unsigned int;
}


class Joueur {
- IA : bool
- pseudo: string
- nombre_couronnes: int
- points_prestige_total:int
- points_prestige_couleurs:int[5]
- nb_cartes_reservees : int
- cartes_reservees:CarteJoaillerie[]
- cartes_main:CarteJoaillerie[6]
- cartes_noble:CarteNoble[]
- gemmes_bonus:int[5]
- privileges:Privilege[]
- nombre_de_privileges : int
- adversaire : Joueur*
- droit_de_rejouer : bool

+ Joueur(nom : string const)
+ getPointsPrestigeTotal() : int const
+ getPseudo() : string const
+ getNombreCouronnes() : int const
+ getPointsPrestigeCouleurs(index : int) : int const
+ getCarteReservee(index : int) : CarteJoaillerie const
+ getCarteNoble(index : int) : CarteNoble const
+ getGemmesBonus(index : int) : int const
+ getPrivilege(index : int) : Privilege const
+ ajouterCarteJoaillerie(carte : CarteJoaillerie) : void
+ ajouterCarteNoble(carte : const CarteNoble&) : void : void
+ ajouterCarteReservee(carte : const CarteJoaillerie&) : void
+ ajouterPrivilege(privilege : const Privilege&) : void
+ setPointsPrestigeCouleurs(index : int, valeur : int) void
+ setGemmesBonus(index : int, value : int) : void
+ getAdversaire() : Joueur *
+ setAdverxaire(adv : Joueur *) : void
+ hasPrivilege() : bool
+ removePrivilege() : Privilege
+ peutRejouer() : bool
+ resetRejouer(reset : bool) : void
}

class IA {
- difficulte: Difficulte
+ IA(pseudo : const string&, diff : difficulte)
}

class Humain {
+ Humain(pseudo : const string&)
}

enum Difficulte <<enumeration>> {
 facile
 moyen
 difficile
}

enum JetonType <<enumeration>> {
Or
Gemme
}
class Jeton {
-type: JetonType
-couleur: Couleur
-chemin_vers_image: string
+afficher() const;
+getCouleurString() const: string;
+getCouleur() const: Couleur;
+getType() const: JetonType
}

enum PrivilegeStatus <<enumeration>> {
NONE
POSSEDE
}
class Privilege {
-status: PrivilegeStatus
+getStatus(): PrivilegeStatus
+setStatus(p:PrivilegeStatus)
}


enum Couleur <<enumeration>> {
 bleu
 vert
 rouge
 blanc
 noir
 rose
 rien
 choix_utilisateur
}

class Pioche{
- numero_pioche:int
- cartes_dans_pioche:CarteJoaillerie[]
- cartes_dehors:CarteJoaillerie[]
- max_cartes_revelees:int
+ joueurPrend(numero_carte:int):CarteJoaillerie
+ distribution()
}

class Carte {
# chemin_vers_image:string
# point_prestige:int
# courronnes:int
# pouvoirs: array<Pouvoir, 2>
# plateau: Plateau*
# joueur: Joueur*
+ actionPouvoir()
+ getPointsPrestige(): int
+ getCourronnes(): int
+ existancePouvoir():array<Pouvoir, 2>
# prendrePrivilege():Privilege
# volerJeton():bool
# prendreJeton():bool
# rejouer()
# rajouteBonus()
}
note left: S'il n'y a pas de pouvoir, alors pouvoirs[index]=rien

class CarteNoble {
-couronne{2,3}: int
-pointPrestige: int
-exigences: map<Couleur, int>
+getCouronne(): int const;
+getPointPrestige(): int const;
+getExigences(): map<Couleur, int> const;
}

class CarteJoaillerie {
-niveau[1..3]: int
-couronne[0..2]: int
-pierres: array<Couleur, 2>
-prix: map<Couleur, int>
+getPrix():map<Couleur, int> const
+getNiveau(): int const
+hasPierre(): bool const;
+getTypePierre(): Couleur const;
+setPierreColor(index:int, couleur:Couleur);
+getPierres(): array<Couleur, 2> const;
+getNombrePierre(): int const;
}
note left: S'il n'y a pas de pierre, alors pierres[index]=rien


enum Pouvoir <<enumeration>> {
 rien
 nouveau_tour
 bonus_pierre
 pierre_en_plus
 privilege_en_plus
 vol_pierre
}


class Optionnelle {
- depenserPrivilege()
- remplissagePlateau(): Plateau
}

class Obligatoire {
- prendreJeton(): Jeton[]
- reserverCarte():CarteJoaillerie
- acheterCarte():CarteJoaillerie
}

Joueur <|-- IA
Joueur <|-- Humain

Jeu *--- "1" Plateau
Jeu *-- "2" Joueur
Jeu *-- "3" Pioche
Jeu *--"1" Affichage
Jeu *--"0..2" Optionnelle
Jeu *--"0..3" Obligatoire

Plateau "1" --- "0...25" Jeton: possède >
Plateau "1"--"0..3" Privilege: comporte >
Plateau o---"0...4" CarteNoble: contient >
Plateau --- ReponseValidationSelection : utilise en valeur de retour >
'Plateau "1"-"3" Pioche

Pioche o--"0..67" CarteJoaillerie

Joueur "1" -- "0..3" Privilege: détient >
Joueur "1" --- "0..10" Jeton: possède >
Joueur o--"0..2" CarteNoble

Carte <|-- CarteNoble
Carte <|-- CarteJoaillerie
'(CarteJoaillerie, Pierre) .. AchatCarte






@enduml
