@startuml

class Jeu {
- handler:static Handler
- joueur_actuel: Joueur*
- joueur_gagnant: Joueur*
--
- libereJeu():void
- nouvellePartie():void
- reprendrePartie():void
- verifAnciennePartie():void
- verifGagnant(Joueur * j1, Joueur * j2): void
- sauvegarderPartie():void
- vainqueur(Joueur * j): void
- auSuivant(Joueur * j1, Joueur * j2): void
- verifCarteNoble(Joueur * j, Plateau * p): void
- manche(Plateau * p, Pioche * p1, Pioche * p2, Pioche * p3, Joueur * j1, Joueur * j2, Obligatoire * obl, Optionnelle * opt): void
- tour(Plateau * p, Pioche * p1, Pioche * p2, Pioche * p3, Joueur * j, Obligatoire * obl, Optionnelle * opt): void
+ getJoueurActuel() const: Joueur*
+ getJoueurGagnant() const: Joueur*
+ validationAction()
}

struct Handler {
    + instance:Jeu *
}

class Affichage{
- affichage()
- afficherRegles()
- afficherConditionVictoire()
- afficherPoint()
}


class Plateau {
- jetons:Jeton[25]
- privilege:Privilege[3]
- sac:Jeton[3]
- cartes_nobles:CarteNoble[3]
- nb_jetons_sac : unsigned int
- nb_jetons_plateau : unsigned int
- pointeur_case_libre : unsigned int
- nb_privileges : unsigned int
- nb_carte_noble : unsigned int
- selection_courante : const Jeton[]
- selection_courante_positions : int[]
- nombre_jetons_dans_selection : unsigned int
- nombre_jetons_par_cote_de_plateau unsigned int
- nombre_jetons_dans_selection_MAX unsigned int
- nb_jetons_sac_MAX  unsigned int
- nb_privileges_MAX  unsigned int
- nb_jetons_plateau_MAX unsigned int
- matrix: unsigned int[5][5]
-- methods --
- parcoursPlateauVerificationPosition(unsigned int x, unsigned int y, int, int) : std::vector<unsigned int>
+ verificationSelectionPositions() : bool
+ remplissagePlateau(bool avecAffichage = false):
+ etatPlateau() : string
+ ajouterSac(const Jeton *j)
+ selectionJeton(unsigned int position_x, unsigned int position_y): int
+ validerSelectionEtPrendreJetons() : std::vector<const Jeton*>
+ prendreJeton(unsigned int position_x, unsigned int position_y) : const Jeton
+ prendrePrivilege() : const Privilege*
+ donnePrivilege(const Privilege* p)
+ prendreCarteNoble(unsigned int numero) : const CarteNoble*
+ hasJeton() : bool
+ getNbJetonsPlateau() const : unsigned int
+ getNbJetonsPlateauMAX() const : unsigned int
+ getNbJetonsSac() const : unsigned int
+ getNbPrivilegeMAX() const : unsigned int
+ getNbPrivileges() const : unsigned int
+ hasJetonOr() : bool
+ donnePositionsPossiblesAPartirDe((unsigned int, unsigned int) : std::vector<std::vector<unsigned int>>
}


abstract class Joueur {
    # pseudo: string
    # nombre_couronnes: int
    # points_prestige_total: int
    # points_prestige_couleurs: vector<int>
    # cartes_reservees: vector<CarteJoaillerie*>
    # cartes_main: vector<CarteJoaillerie*>
    # cartes_noble: vector<CarteNoble*>
    # gemmes_bonus: vector<int>
    # nb_jeton: vector<int>
    # privileges: vector<Privilege*>
    # adversaire: Joueur*
    # droit_de_rejouer: bool

    + Joueur(nom: string const)
    + getPointsPrestigeTotal(): int const
    + getPseudo(): string const
    + getNombreCouronnes(): int const
    + getPointsPrestigeCouleurs(index: int): int const
    + getCarteReservee(index: int): CarteJoaillerie const
    + getCarteNoble(index: int): CarteNoble const
    + getGemmesBonus(index: int): int const
    + getPrivilege(index: int): Privilege const
    + ajouterCarteJoaillerie(carte: CarteJoaillerie): void
    + ajouterCarteNoble(carte: const CarteNoble&): void
    + ajouterCarteReservee(carte: const CarteJoaillerie&): void
    + ajouterPrivilege(privilege: const Privilege&): void
    + setPointsPrestigeCouleurs(index: int, valeur: int): void
    + setGemmesBonus(index: int, value: int): void
    + getAdversaire(): Joueur*
    + setAdversaire(adv: Joueur*): void
    + hasPrivilege(): bool
    + removePrivilege(): Privilege
    + peutRejouer(): bool
    + resetRejouer(reset: bool): void
    + getNbJeton(index: int): int
    + setNbJeton(index: int, value: int): void
    + getNombreDePrivileges(): int
    + getNbCartesReservees(): int
    + choisirChoix(min: int, max: int): int virtuelle
}

class IA {
    - difficulte: Difficulte

      + IA(pseudo: string, diff: Difficulte)
      + choisirChoix(min: int, max: int): int override
      + templateMethod(): void {abstract}
      + operationPrimaire(): void override
      + operationSpecifique(): void override

      {abstract} + choisirJetonSurPlateau(plateau: Plateau): void
      {abstract} + prendreJetons(plateau: Plateau): void
      {abstract} + genererCombinaisonsDeuxJetons(plateau: Plateau): vector<pair<const Jeton*, const Jeton*>>
      {abstract} + genererCombinaisonsTroisJetons(plateau: Plateau): vector<tuple<const Jeton*, const Jeton*, const Jeton*>>
      {abstract} + melangerEtObtenirDerniereCarte(pioche: Pioche, joueur: Joueur): CarteJoaillerie*
      {abstract} + getCartesAchetable(pioche: Pioche): vector<CarteJoaillerie*>

}

class Humain {
    + Humain(pseudo: string)
    + choisirChoix(min: int, max: int): int override
}


enum Difficulte <<enumeration>> {
 facile
 moyen
 difficile
}

enum JetonType <<enumeration>> {
Or
Gemme
}
class Jeton {
-type: JetonType
-couleur: Couleur
-chemin_vers_image: string
-positionX: int
-positionY: int
+afficher() const;
+getCouleurString() const: string;
+getCouleur() const: Couleur;
+getType() const: JetonType
}

enum PrivilegeStatus <<enumeration>> {
NONE
POSSEDE
}

class Privilege {
-status: PrivilegeStatus
+getStatus(): PrivilegeStatus
+setStatus(p:PrivilegeStatus)
}


enum Couleur <<enumeration>> {
 bleu
 vert
 rouge
 blanc
 noir
 rose
 rien
 choix_utilisateur
}

class Pioche{
- numero_pioche:int const
- cartes_dans_pioche:CarteJoaillerie*[] const
- cartes_dehors:CarteJoaillerie*[] const
- max_cartes_revelees:int
- max_cartes_pioche:int const
- getNumeroPioche() const: const int
- getCartesDansPioche(int i) const : const CarteJoaillerie *
- getCartesDehors(int i) const : const CarteJoaillerie *
- getMaxCartesRevelees() const : const int
- getMaxCartesPioche() const : int
- Pioche(const int np, const int mcr, int mcp);
- ~Pioche();
- joueurPrend(int numero_carte): const CarteJoaillerie *
- distribution(): void
- joueurPrendPioche(): const CarteJoaillerie *
}

class Carte {
# chemin_vers_image:string
# point_prestige:int
# courronnes:int
# pouvoirs: array<Pouvoir, 2>
# plateau: Plateau*
# joueur: Joueur*
+ actionPouvoir()
+ getPointsPrestige(): int
+ getCourronnes(): int
+ existancePouvoir():array<Pouvoir, 2>
# prendrePrivilege():Privilege
# volerJeton():bool
# prendreJeton():bool
# rejouer()
# rajouteBonus()
}
note left: S'il n'y a pas de pouvoir, alors pouvoirs[index]=rien

class CarteNoble {
-couronne{2,3}: int
-pointPrestige: int
+getCouronne(): int const;
+getPointPrestige(): int const;
}

class CarteJoaillerie {
-niveau[1..3]: int
-couronne[0..2]: int
-pierres: array<Couleur, 2>
-prix: map<Couleur, int>
+getPrix():map<Couleur, int> const
+getNiveau(): int const
+hasPierre(): bool const;
+getTypePierre(): Couleur const;
+setPierreColor(index:int, couleur:Couleur);
+getPierres(): array<Couleur, 2> const;
+getNombrePierre(): int const;
}
note left: S'il n'y a pas de pierre, alors pierres[index]=rien


enum Pouvoir <<enumeration>> {
 rien
 nouveau_tour
 bonus_pierre
 pierre_en_plus
 privilege_en_plus
 vol_pierre
}


class Optionnelle {
{static} depenserPrivilege(Joueur* joueur, Plateau* plateau)
{static} remplissagePlateau(Joueur* joueur, Plateau* plateau)
}

class Obligatoire {
{static} prendreJeton(Joueur* joueur, Plateau* plateau)
{static} demanderCarteAReserver(Joueur* joueur, Plateau* plateau, Pioche* p1, Pioche* p2, Pioche* p3)
{static} reserverCarte(Joueur* j, Plateau* plateau, Pioche* p1, Pioche* p2, Pioche* p3, int n_pioche, int n_carte, bool carte_revelee = true)
{static} acheterCarte(Joueur* joueur, Plateau* plateau, Pioche* p1, Pioche* p2, Pioche* p3)
{static} remettreJetonSac(Joueur* joueur, Plateau* plateau, Couleur c, int difference, int prix_elem, int index)
{static} ajouterJetonsJoueur(Joueur* joueur, std::vector<const Jeton*> selection): std::vector<int>
{static} achatPiochePossible(Joueur* joueur, Pioche* p): bool
{static} achatCartePossible(Joueur *joueur, std::vector<int> difference): bool
{static} calculDifference(Joueur* joueur, std::map<Couleur, int> prix): std::vector<int>
{static} donnerPrivilegeAdversaire(Joueur* joueur, Plateau* plateau)
}

Joueur <|-- IA
Joueur <|-- Humain

Jeu <.. Handler

Jeu *--- "1" Plateau
Jeu *-- "2" Joueur
Jeu *-- "3" Pioche
Jeu *--"1" Affichage
Jeu *--"0..2" Optionnelle
Jeu *--"0..3" Obligatoire

Plateau "1" --- "0...25" Jeton: possède >
Plateau "1"--"0..3" Privilege: comporte >
Plateau o---"0...4" CarteNoble: contient >
Plateau --- ReponseValidationSelection : utilise en valeur de retour >
'Plateau "1"-"3" Pioche

Pioche o--"0..67" CarteJoaillerie

Joueur "1" -- "0..3" Privilege: détient >
Joueur "1" --- "0..10" Jeton: possède >
Joueur o--"0..2" CarteNoble

Carte <|-- CarteNoble
Carte <|-- CarteJoaillerie
'(CarteJoaillerie, Pierre) .. AchatCarte






@enduml
